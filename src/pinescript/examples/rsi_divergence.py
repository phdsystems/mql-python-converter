"""
RSI Divergence
Converted from Pine Script v5
Auto-generated by Pine Script to Python Converter
"""

import numpy as np
from typing import Dict, List, Optional, Tuple

class RsiDivergence:
    """
    RSI Divergence
    Overlay: False
    """

    def __init__(self
,
                 rsi_length=14
,
                 overbought=70
,
                 oversold=30
,
                 lookback=5
):
        """Initialize indicator with parameters"""
        self.rsi_length = rsi_length
        self.overbought = overbought
        self.oversold = oversold
        self.lookback = lookback

    def calculate(self, data: Dict[str, np.ndarray]) -> Dict[str, np.ndarray]:
        """
        Calculate indicator values
        
        Args:
            data: Dictionary with keys: open, high, low, close, volume
        
        Returns:
            Dictionary with calculated indicator values
        """
        # Extract price data
        self.open = data.get("open", np.array([]))
        self.high = data.get("high", np.array([]))
        self.low = data.get("low", np.array([]))
        self.close = data.get("close", np.array([]))
        self.volume = data.get("volume", np.array([]))
        self.bar_index = np.arange(len(self.close))

        # Initialize result arrays
        n = len(self.close)
        results = {}

        # Calculate indicator values
        rsi_value = self.rsi(self.close, rsi_length)
        results["rsi_value"] = rsi_value
        pivot_high = self.self.highest(self.high, lookback)
        results["pivot_high"] = pivot_high
        pivot_low = self.self.lowest(self.low, lookback)
        results["pivot_low"] = pivot_low
        bullish_div = self.close == pivot_self.low and rsi_value > self.self.lowest(rsi_value, lookback)
        results["bullish_div"] = bullish_div
        bearish_div = self.close == pivot_self.high and rsi_value < self.self.highest(rsi_value, lookback)
        results["bearish_div"] = bearish_div

        return results

    def sma(self, series: np.ndarray, period: int) -> np.ndarray:
        """Simple Moving Average"""
        return np.convolve(series, np.ones(period)/period, mode="same")

    def ema(self, series: np.ndarray, period: int) -> np.ndarray:
        """Exponential Moving Average"""
        alpha = 2 / (period + 1)
        ema = np.zeros_like(series)
        ema[0] = series[0]
        for i in range(1, len(series)):
            ema[i] = alpha * series[i] + (1 - alpha) * ema[i-1]
        return ema

    def rsi(self, series: np.ndarray, period: int) -> np.ndarray:
        """Relative Strength Index"""
        delta = np.diff(series, prepend=series[0])
        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)
        avg_gain = self.rma(gain, period)
        avg_loss = self.rma(loss, period)
        rs = avg_gain / (avg_loss + 1e-10)
        return 100 - (100 / (1 + rs))

    def rma(self, series: np.ndarray, period: int) -> np.ndarray:
        """Running Moving Average (Wilder smoothing)"""
        alpha = 1 / period
        rma = np.zeros_like(series)
        rma[0] = series[0]
        for i in range(1, len(series)):
            rma[i] = alpha * series[i] + (1 - alpha) * rma[i-1]
        return rma

    def crossover(self, series1: np.ndarray, series2: np.ndarray) -> np.ndarray:
        """Check if series1 crosses over series2"""
        return (series1 > series2) & (np.roll(series1, 1) <= np.roll(series2, 1))

    def crossunder(self, series1: np.ndarray, series2: np.ndarray) -> np.ndarray:
        """Check if series1 crosses under series2"""
        return (series1 < series2) & (np.roll(series1, 1) >= np.roll(series2, 1))

    def highest(self, series: np.ndarray, period: int) -> np.ndarray:
        """Rolling maximum"""
        from scipy.ndimage import maximum_filter1d
        return maximum_filter1d(series, size=period, mode="constant")

    def lowest(self, series: np.ndarray, period: int) -> np.ndarray:
        """Rolling minimum"""
        from scipy.ndimage import minimum_filter1d
        return minimum_filter1d(series, size=period, mode="constant")

    def change(self, series: np.ndarray, period: int = 1) -> np.ndarray:
        """Price change over period"""
        return series - np.roll(series, period)



def example_usage():
    """Example usage of the indicator"""
    import numpy as np
    
    # Generate sample data
    n = 100
    data = {
        "open": np.random.randn(n).cumsum() + 100,
        "high": np.random.randn(n).cumsum() + 101,
        "low": np.random.randn(n).cumsum() + 99,
        "close": np.random.randn(n).cumsum() + 100,
        "volume": np.random.randint(1000, 10000, n)
    }
    
    # Create indicator instance
    indicator = RsiDivergence()
    # With custom parameters:
    # indicator = RsiDivergence(rsi_length=14, overbought=70, oversold=30)
    
    # Calculate indicator values
    results = indicator.calculate(data)
    
    # Print results
    for key, values in results.items():
        print(f"{key}: {values[-5:]}")  # Last 5 values


if __name__ == "__main__":
    example_usage()