"""
Pine Script to Python Converter
Converts Pine Script indicators to Python code
"""

from typing import Dict, List, Any, Optional
import re
from pinescript_parser import PineIndicator, PineVariable, PineFunction, PineType


class PineScriptToPython:
    """Converts Pine Script code to Python"""
    
    # Pine Script to Python function mappings
    FUNCTION_MAP = {
        # Math functions
        'math.abs': 'abs',
        'math.sign': 'np.sign',
        'math.round': 'round',
        'math.floor': 'np.floor',
        'math.ceil': 'np.ceil',
        'math.sqrt': 'np.sqrt',
        'math.pow': 'np.power',
        'math.exp': 'np.exp',
        'math.log': 'np.log',
        'math.log10': 'np.log10',
        'math.max': 'max',
        'math.min': 'min',
        'math.avg': 'np.mean',
        'math.sum': 'np.sum',
        
        # Technical analysis functions
        'ta.sma': 'self.sma',
        'ta.ema': 'self.ema',
        'ta.rma': 'self.rma',
        'ta.wma': 'self.wma',
        'ta.vwma': 'self.vwma',
        'ta.rsi': 'self.rsi',
        'ta.macd': 'self.macd',
        'ta.bb': 'self.bollinger_bands',
        'ta.stoch': 'self.stochastic',
        'ta.atr': 'self.atr',
        'ta.tr': 'self.true_range',
        'ta.change': 'self.change',
        'ta.roc': 'self.roc',
        'ta.crossover': 'self.crossover',
        'ta.crossunder': 'self.crossunder',
        'ta.highest': 'self.highest',
        'ta.lowest': 'self.lowest',
        'ta.stdev': 'np.std',
        'ta.variance': 'np.var',
        'ta.correlation': 'np.corrcoef',
        
        # Built-in variables
        'close': 'self.close',
        'open': 'self.open',
        'high': 'self.high',
        'low': 'self.low',
        'volume': 'self.volume',
        'time': 'self.time',
        'bar_index': 'self.bar_index',
        'na': 'np.nan',
        'true': 'True',
        'false': 'False',
        
        # Operators
        'and': 'and',
        'or': 'or',
        'not': 'not',
    }
    
    # Pine Script to Python operator mappings
    OPERATOR_MAP = {
        ':=': '=',
        '?': 'if',
        ':': 'else',
        '==': '==',
        '!=': '!=',
        '>': '>',
        '<': '<',
        '>=': '>=',
        '<=': '<=',
    }
    
    def __init__(self):
        self.imports = set()
        self.helper_functions = {}
        
    def convert(self, indicator: PineIndicator) -> str:
        """
        Convert Pine Script indicator to Python code
        
        Args:
            indicator: Parsed PineIndicator object
            
        Returns:
            Python code string
        """
        self.imports = {'numpy as np'}
        self.helper_functions = {}
        
        # Build Python class
        code_lines = []
        
        # Add header
        code_lines.extend(self._generate_header(indicator))
        
        # Add imports
        code_lines.extend(self._generate_imports())
        
        # Add class definition
        code_lines.extend(self._generate_class(indicator))
        
        # Add helper functions if needed
        if self.helper_functions:
            code_lines.extend(self._generate_helpers())
        
        # Add example usage
        code_lines.extend(self._generate_example(indicator))
        
        return '\n'.join(code_lines)
    
    def _generate_header(self, indicator: PineIndicator) -> List[str]:
        """Generate file header"""
        return [
            '"""',
            f'{indicator.title}',
            f'Converted from Pine Script v{indicator.version}',
            'Auto-generated by Pine Script to Python Converter',
            '"""',
            ''
        ]
    
    def _generate_imports(self) -> List[str]:
        """Generate import statements"""
        lines = []
        for imp in sorted(self.imports):
            lines.append(f'import {imp}')
        lines.append('from typing import Dict, List, Optional, Tuple')
        lines.append('')
        return lines
    
    def _generate_class(self, indicator: PineIndicator) -> List[str]:
        """Generate main indicator class"""
        lines = []
        
        # Class definition
        class_name = self._sanitize_name(indicator.title)
        lines.append(f'class {class_name}:')
        lines.append(f'    """')
        lines.append(f'    {indicator.title}')
        if indicator.shorttitle:
            lines.append(f'    Short Title: {indicator.shorttitle}')
        lines.append(f'    Overlay: {indicator.overlay}')
        lines.append(f'    """')
        lines.append('')
        
        # Constructor
        lines.extend(self._generate_constructor(indicator))
        
        # Calculate method
        lines.extend(self._generate_calculate_method(indicator))
        
        # Helper methods for technical indicators
        lines.extend(self._generate_ta_methods())
        
        # Custom functions
        for func_name, func in indicator.functions.items():
            lines.extend(self._generate_function(func))
        
        return lines
    
    def _generate_constructor(self, indicator: PineIndicator) -> List[str]:
        """Generate __init__ method"""
        lines = ['    def __init__(self']
        
        # Add input parameters
        for var_name, var in indicator.variables.items():
            if var.is_input:
                default = var.value if var.value is not None else 'None'
                lines.append(f',\n                 {var_name}={default}')
        
        lines.append('):')
        lines.append('        """Initialize indicator with parameters"""')
        
        # Initialize parameters
        for var_name, var in indicator.variables.items():
            if var.is_input:
                lines.append(f'        self.{var_name} = {var_name}')
        
        lines.append('')
        return lines
    
    def _generate_calculate_method(self, indicator: PineIndicator) -> List[str]:
        """Generate main calculate method"""
        lines = []
        lines.append('    def calculate(self, data: Dict[str, np.ndarray]) -> Dict[str, np.ndarray]:')
        lines.append('        """')
        lines.append('        Calculate indicator values')
        lines.append('        ')
        lines.append('        Args:')
        lines.append('            data: Dictionary with keys: open, high, low, close, volume')
        lines.append('        ')
        lines.append('        Returns:')
        lines.append('            Dictionary with calculated indicator values')
        lines.append('        """')
        
        # Extract price data
        lines.append('        # Extract price data')
        lines.append('        self.open = data.get("open", np.array([]))')
        lines.append('        self.high = data.get("high", np.array([]))')
        lines.append('        self.low = data.get("low", np.array([]))')
        lines.append('        self.close = data.get("close", np.array([]))')
        lines.append('        self.volume = data.get("volume", np.array([]))')
        lines.append('        self.bar_index = np.arange(len(self.close))')
        lines.append('')
        
        # Initialize result arrays
        lines.append('        # Initialize result arrays')
        lines.append('        n = len(self.close)')
        lines.append('        results = {}')
        lines.append('')
        
        # Convert variables
        lines.append('        # Calculate indicator values')
        for var_name, var in indicator.variables.items():
            if not var.is_input and var.value:
                python_expr = self._convert_expression(var.value)
                lines.append(f'        {var_name} = {python_expr}')
                
                # Add to results if it's a main output
                if var.is_series:
                    lines.append(f'        results["{var_name}"] = {var_name}')
        
        lines.append('')
        lines.append('        return results')
        lines.append('')
        
        return lines
    
    def _generate_ta_methods(self) -> List[str]:
        """Generate technical analysis helper methods"""
        lines = []
        
        # SMA
        lines.extend([
            '    def sma(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Simple Moving Average"""',
            '        return np.convolve(series, np.ones(period)/period, mode="same")',
            ''
        ])
        
        # EMA
        lines.extend([
            '    def ema(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Exponential Moving Average"""',
            '        alpha = 2 / (period + 1)',
            '        ema = np.zeros_like(series)',
            '        ema[0] = series[0]',
            '        for i in range(1, len(series)):',
            '            ema[i] = alpha * series[i] + (1 - alpha) * ema[i-1]',
            '        return ema',
            ''
        ])
        
        # RSI
        lines.extend([
            '    def rsi(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Relative Strength Index"""',
            '        delta = np.diff(series, prepend=series[0])',
            '        gain = np.where(delta > 0, delta, 0)',
            '        loss = np.where(delta < 0, -delta, 0)',
            '        avg_gain = self.rma(gain, period)',
            '        avg_loss = self.rma(loss, period)',
            '        rs = avg_gain / (avg_loss + 1e-10)',
            '        return 100 - (100 / (1 + rs))',
            ''
        ])
        
        # RMA (Running Moving Average)
        lines.extend([
            '    def rma(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Running Moving Average (Wilder smoothing)"""',
            '        alpha = 1 / period',
            '        rma = np.zeros_like(series)',
            '        rma[0] = series[0]',
            '        for i in range(1, len(series)):',
            '            rma[i] = alpha * series[i] + (1 - alpha) * rma[i-1]',
            '        return rma',
            ''
        ])
        
        # Crossover
        lines.extend([
            '    def crossover(self, series1: np.ndarray, series2: np.ndarray) -> np.ndarray:',
            '        """Check if series1 crosses over series2"""',
            '        return (series1 > series2) & (np.roll(series1, 1) <= np.roll(series2, 1))',
            ''
        ])
        
        # Crossunder
        lines.extend([
            '    def crossunder(self, series1: np.ndarray, series2: np.ndarray) -> np.ndarray:',
            '        """Check if series1 crosses under series2"""',
            '        return (series1 < series2) & (np.roll(series1, 1) >= np.roll(series2, 1))',
            ''
        ])
        
        # Highest
        lines.extend([
            '    def highest(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Rolling maximum"""',
            '        from scipy.ndimage import maximum_filter1d',
            '        return maximum_filter1d(series, size=period, mode="constant")',
            ''
        ])
        
        # Lowest
        lines.extend([
            '    def lowest(self, series: np.ndarray, period: int) -> np.ndarray:',
            '        """Rolling minimum"""',
            '        from scipy.ndimage import minimum_filter1d',
            '        return minimum_filter1d(series, size=period, mode="constant")',
            ''
        ])
        
        # Change
        lines.extend([
            '    def change(self, series: np.ndarray, period: int = 1) -> np.ndarray:',
            '        """Price change over period"""',
            '        return series - np.roll(series, period)',
            ''
        ])
        
        return lines
    
    def _generate_function(self, func: PineFunction) -> List[str]:
        """Generate Python function from Pine Script function"""
        lines = []
        
        # Function definition
        params_str = ', '.join(['self'] + func.params)
        lines.append(f'    def {func.name}({params_str}):')
        lines.append(f'        """Custom function: {func.name}"""')
        
        # Convert function body
        for line in func.body:
            python_line = self._convert_expression(line)
            lines.append(f'        {python_line}')
        
        lines.append('')
        return lines
    
    def _generate_helpers(self) -> List[str]:
        """Generate helper functions"""
        lines = ['', '# Helper Functions', '']
        
        for func_name, func_code in self.helper_functions.items():
            lines.extend(func_code)
            lines.append('')
        
        return lines
    
    def _generate_example(self, indicator: PineIndicator) -> List[str]:
        """Generate example usage code"""
        lines = ['', '', 'def example_usage():', '    """Example usage of the indicator"""']
        
        class_name = self._sanitize_name(indicator.title)
        
        lines.extend([
            '    import numpy as np',
            '    ',
            '    # Generate sample data',
            '    n = 100',
            '    data = {',
            '        "open": np.random.randn(n).cumsum() + 100,',
            '        "high": np.random.randn(n).cumsum() + 101,',
            '        "low": np.random.randn(n).cumsum() + 99,',
            '        "close": np.random.randn(n).cumsum() + 100,',
            '        "volume": np.random.randint(1000, 10000, n)',
            '    }',
            '    ',
            f'    # Create indicator instance',
            f'    indicator = {class_name}()'
        ])
        
        # Add parameters if any
        input_vars = [v for v in indicator.variables.values() if v.is_input]
        if input_vars:
            lines.append('    # With custom parameters:')
            params = ', '.join([f'{v.name}={v.value}' for v in input_vars[:3]])
            lines.append(f'    # indicator = {class_name}({params})')
        
        lines.extend([
            '    ',
            '    # Calculate indicator values',
            '    results = indicator.calculate(data)',
            '    ',
            '    # Print results',
            '    for key, values in results.items():',
            '        print(f"{key}: {values[-5:]}")  # Last 5 values',
            '',
            '',
            'if __name__ == "__main__":',
            '    example_usage()'
        ])
        
        return lines
    
    def _convert_expression(self, expr: str) -> str:
        """Convert Pine Script expression to Python"""
        # Handle ternary operator (? :)
        if '?' in expr and ':' in expr:
            parts = expr.split('?')
            condition = parts[0].strip()
            true_false = parts[1].split(':')
            true_val = true_false[0].strip()
            false_val = true_false[1].strip() if len(true_false) > 1 else 'None'
            
            expr = f'{true_val} if {condition} else {false_val}'
        
        # Replace Pine Script functions with Python equivalents
        for pine_func, py_func in self.FUNCTION_MAP.items():
            expr = expr.replace(pine_func, py_func)
        
        # Replace operators
        for pine_op, py_op in self.OPERATOR_MAP.items():
            if pine_op != '?' and pine_op != ':':  # Already handled
                expr = expr.replace(pine_op, py_op)
        
        # Handle array indexing [n]
        expr = re.sub(r'\[(\d+)\]', r'[self.bar_index - \1]', expr)
        
        # Handle nz() function (replace NaN with 0)
        expr = re.sub(r'nz\((.*?)\)', r'np.nan_to_num(\1)', expr)
        
        # Add scipy import if needed
        if 'minimum_filter1d' in expr or 'maximum_filter1d' in expr:
            self.imports.add('scipy.ndimage')
        
        return expr
    
    def _sanitize_name(self, name: str) -> str:
        """Convert indicator name to valid Python class name"""
        # Remove special characters and convert to CamelCase
        name = re.sub(r'[^a-zA-Z0-9\s]', '', name)
        words = name.split()
        return ''.join(word.capitalize() for word in words)


def convert_pinescript_to_python(pinescript_code: str) -> str:
    """
    Convert Pine Script code to Python
    
    Args:
        pinescript_code: Pine Script source code
        
    Returns:
        Python code string
    """
    from pinescript_parser import parse_pinescript
    
    # Parse Pine Script
    indicator = parse_pinescript(pinescript_code)
    
    # Convert to Python
    converter = PineScriptToPython()
    python_code = converter.convert(indicator)
    
    return python_code